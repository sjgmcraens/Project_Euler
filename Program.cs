using System;
using System.Collections;
using System.Collections.Generic;
using System.Data.Common;
using System.Dynamic;
using System.Linq;
using System.Reflection;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Xml.Schema;

namespace Project_Euler
{
    class Program
    {

        static void Main()
        {
            // Variabes we might need.
            string sectionBar = "\n========================================================================================================================\n";
            //bool firstMenuLoop = true;

            // Main loop ==> Like a menu, you can come back to it or exit out.
            while (true)
            {

                // Show the user a list of the problems
                Console.WriteLine(sectionBar);
                Console.WriteLine("List of problems: ("+Problems.P.Count+" total)");
                foreach (KeyValuePair<int, Problem> entry in Problems.P.OrderBy(key => key.Key))
                {
                    Console.WriteLine(String.Format("[{0}]: {1}", entry.Key, entry.Value.Title));
                }



                // Ask the user to input the ID of the desired problem; the program can be exited at this point.
                Console.WriteLine(sectionBar);
                Console.WriteLine("Please input the ID of a problem to print it's details.\n" +
                    "To exit the program, input 'exit'.");
                string Input = Console.ReadLine();
                if (Input == "exit") { return; }
                int ID = Convert.ToInt32(Input);

                // Some control for input
                while (!Problems.P.ContainsKey(ID))
                {
                    Console.WriteLine("Please input an existing ID.");
                    Input = Console.ReadLine();
                    if (Input == "exit") { return; }
                    ID = Convert.ToInt32(Input);
                }

                // Print the details of the selected problem
                Console.WriteLine(sectionBar);
                Problem p = Problems.P[ID];
                Console.WriteLine(p.Title + ":\n" + p.Discription + "\n\nSolved by: " +
                    p.Solved_by + "\nDifficulty: " + p.Difficulty + "%\n\nSolution: " + p.Solution());

                // Ask the user what to do next
                Console.WriteLine(sectionBar);
                Console.WriteLine("Input 'exit' to exit the program; any other input will return you to the list of problems.");
                Input = Console.ReadLine();
                // If the input isn't '1', close the program
                if (Input == "exit")
                {
                    return;
                }

                //firstMenuLoop = false;
            }
        }

        static class Problems
        // This class contains the information pertaining to the all the problems.
        {
            // Dictinairy of problems
            public static readonly Dictionary<int, Problem> P;

            static Problems() // This is the constructor: below, we fill 'P' and add methods for returning the solution to the problems.
            {

                P = new Dictionary<int, Problem>();

                P.Add(1, new Problem("Multiples of 3 and 5",
                    "If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.\n" +
                    "Find the sum of all the multiples of 3 or 5 below 1000.",
                    964994, 5, Sol_1));

                P.Add(7, new Problem("10001st prime",
                    "By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.\n" +
                    "What is the 10 001st prime number?",
                    421486, 5, Sol_7));

                P.Add(31, new Problem("Coin sums",
                    "In the United Kingdom the currency is made up of pound (£) and pence (p). There are eight coins in general circulation:\n" +
                    "1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), and £2 (200p).\n" +
                    "It is possible to make £2 in the following way:\n" +
                    "1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p\n" +
                    "How many different ways can £2 be made using any number of coins?",
                    84093, 5, Sol_31));

                P.Add(2, new Problem("Even Fibonacci numbers",
                    "Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n" +
                    "1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n" +
                    "By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.",
                    768279, 5, Sol_2));

                P.Add(3, new Problem("Largest prime factor",
                    "The prime factors of 13195 are 5, 7, 13 and 29.\n" +
                    "What is the largest prime factor of the number 600851475143 ?",
                    550872, 5, Sol_3));

                P.Add(4, new Problem("Largest palindrome product",
                    "A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.\n" +
                    "Find the largest palindrome made from the product of two 3-digit numbers.",
                    486673, 5, Sol_4));
                
                P.Add(5, new Problem("Smallest multiple",
                    "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.\n" +
                    "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?",
                    486673, 5, Sol_5));

                P.Add(6, new Problem("Sum square difference",
                    "The sum of the squares of the first ten natural numbers is,\n" +
                    "1+4+9+...+100 = 385\n" +
                    "The square of the sum of the first ten natural numbers is,\n" +
                    "(1+2+3+...+10)^2 = 3025\n" +
                    "Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is,\n" +
                    "3025-385 = 2640\n" +
                    "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.",
                    493325, 5, Sol_6));

                P.Add(8, new Problem("Largest product in a series",
                    "The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.,\n" +
                    "73167176531330624919225119674426574742355349194934\n" +
                    "96983520312774506326239578318016984801869478851843\n" +
                    "85861560789112949495459501737958331952853208805511\n" +
                    "12540698747158523863050715693290963295227443043557\n" +
                    "66896648950445244523161731856403098711121722383113\n" +
                    "62229893423380308135336276614282806444486645238749\n" +
                    "30358907296290491560440772390713810515859307960866\n" +
                    "70172427121883998797908792274921901699720888093776\n" +
                    "65727333001053367881220235421809751254540594752243\n" +
                    "52584907711670556013604839586446706324415722155397\n" +
                    "53697817977846174064955149290862569321978468622482\n" +
                    "83972241375657056057490261407972968652414535100474\n" +
                    "82166370484403199890008895243450658541227588666881\n" +
                    "16427171479924442928230863465674813919123162824586\n" +
                    "17866458359124566529476545682848912883142607690042\n" +
                    "24219022671055626321111109370544217506941658960408\n" +
                    "07198403850962455444362981230987879927244284909188\n" +
                    "84580156166097919133875499200524063689912560717606\n" +
                    "05886116467109405077541002256983155200055935729725\n" +
                    "71636269561882670428252483600823257530420752963450\n" +
                    "Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?",
                    352346, 5, Sol_8));

                P.Add(9, new Problem("Special Pythagorean triplet",
                    "A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,\n" +
                    "a2 + b2 = c2\n" +
                    "For example, 32 + 42 = 9 + 16 = 25 = 52.\n" +
                    "There exists exactly one Pythagorean triplet for which a + b + c = 1000.\n" +
                    "Find the product abc.\n",
                    357757, 5, Sol_9));

                P.Add(10, new Problem("Summation of primes",
                    "The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.\n" +
                    "Find the sum of all the primes below two million.\n",
                    327678, 5, Sol_10));

                P.Add(11, new Problem("Largest product in a grid",
                    "In the 20×20 grid below, four numbers along a diagonal line have been marked in red.\n" +
                    "08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08\n" +
                    "49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00\n" +
                    "81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65\n" +
                    "52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91\n" +
                    "22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80\n" +
                    "24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50\n" +
                    "32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70\n" +
                    "67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21\n" +
                    "24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72\n" +
                    "21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95\n" +
                    "78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92\n" +
                    "16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57\n" +
                    "86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58\n" +
                    "19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40\n" +
                    "04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66\n" +
                    "88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69\n" +
                    "04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36\n" +
                    "20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16\n" +
                    "20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54\n" +
                    "01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48\n" +
                    "The product of these numbers is 26 × 63 × 78 × 14 = 1788696./n" +
                    "What is the greatest product of four adjacent numbers in the same direction (up, down, left, right, or diagonally) in the 20×20 grid?",
                    234222, 5, Sol_11));
            }

            public static string Sol_1()
            {
                // Multiples of 3 and 5

                // For every natural number under 1000
                int stopAt = 1000;
                int total = 0;
                for (int i = 0; i < stopAt; i++)
                {
                    // Add it to the total if it is divisible by 3 or 5
                    if (i % 3 == 0 || i % 5 == 0)
                    {
                        total += i;
                    }
                }
                return $"Answer: {total}";
            }

            public static string Sol_2() // Even Fibbonachi numbers
            {
                List<int> Fib = new List<int>() { 1, 2 };
                int target = 4000000;
                long total = 2;
                while (Fib[Fib.Count - 1] < target) // While < 4000000
                {
                    int nextFib = Fib[Fib.Count - 1] + Fib[Fib.Count - 2];
                    Fib.Add(nextFib);
                    if (nextFib % 2 == 0) // If even
                    {
                        total += nextFib;
                    }
                }
                return $"Answer: {total}";
            }

            public static string Sol_3()
            {
                //Largest prime factor
                long numToFactor = 600851475143;
                List<long> factors = Prime.GetPrimeFactors(numToFactor);
                return $"Answer: {factors.Max()}";
            }

            public static string Sol_4()
            {
                //Largest palindrome product

                // I think it's best to check palindrome from largest to smallest.
                // Since it must be a multiple of two three-digit numbers, 998001 is going to be the starting point.
                // Instead of brute-forcing all multiplications (999*999, 998*999 ...), Lets go down from 998001 
                // and keep checking palindromes untill we find one that can be made with two three-digit numbers. 

                // Settings
                int Multdigits = 3;
                int Multamount = 2; // Doesn't work for inputs > 2 unfortunately.

                // Some preparatory calculations.
                int maxMult = Int32.Parse(String.Concat(Enumerable.Repeat("9", Multdigits))); // 999
                int maxTotal = Convert.ToInt32(Math.Pow(maxMult, Multamount)); // 999*999 = 998001

                int minMult = Convert.ToInt32(Math.Pow(10, Multdigits - 1)); // 100
                int minTotal = Convert.ToInt32(Math.Pow(minMult, Multamount)); // 100*100 = 100000

                string maxTotal_str = Math.Pow(maxMult, Multamount).ToString(); // 998001

                // Determine first palindrome
                int palindrome = GetLargestPalinDromeBelow(maxTotal);

                while (palindrome >= minTotal)
                {
                    //Console.WriteLine(palindrome);

                    // Now that we have a palindrome, lets check whether it can be made using two three-digit numbers
                    for (int i = maxMult; i >= minMult; i--) // 999, 998, ... , 100
                    {
                        if (palindrome % i == 0) // If wholly divisible (to completely generalize: make this recursive)
                        {
                            if ((palindrome / i).ToString().Length == Multdigits) // If the division creates a 3-digit number.
                            {
                                //Console.WriteLine(String.Format("Palindrome {0} can be made using {1} x {2}",palindrome,i,palindrome / i));
                                return $"Answer: {palindrome}"; // Return the succesfull palindrome.
                            }
                        }
                    }
                    palindrome = GetLargestPalinDromeBelow(palindrome - 1);
                }
                // No solution was found.
                return "No solution was found.";
            }

            public static string Sol_5()
            {
                // Smallest multiple

                List<int> ns = new List<int>();
                for (int i = 1; i <= 20; i++)
                {
                    ns.Add(i);
                }
                return $"Answer: {LowestCommonMultiple(ns)}";
            }

            public static string Sol_6()
            {
                // Sum square difference

                int upTo = 100;
                double sumOfQuares = 0;
                int sum = 0;
                for (int i = 1; i <= upTo; i++)
                {
                    sumOfQuares += Math.Pow(i, 2);
                    sum += i;
                }
                double squareOfSum = Math.Pow(sum, 2);
                return $"Answer: {Math.Abs(squareOfSum - sumOfQuares)}";
            }


            public static string Sol_7() // 10001st prime
            {
                return $"Answer: {Prime.GetPrimeAtIndex(10000)}"; // See also the static class 'Prime'
            }

            public static string Sol_8()
            {
                int lengthOfProduct = 13;

                string N = "73167176531330624919225119674426574742355349194934" +
                           "96983520312774506326239578318016984801869478851843" +
                           "85861560789112949495459501737958331952853208805511" +
                           "12540698747158523863050715693290963295227443043557" +
                           "66896648950445244523161731856403098711121722383113" +
                           "62229893423380308135336276614282806444486645238749" +
                           "30358907296290491560440772390713810515859307960866" +
                           "70172427121883998797908792274921901699720888093776" +
                           "65727333001053367881220235421809751254540594752243" +
                           "52584907711670556013604839586446706324415722155397" +
                           "53697817977846174064955149290862569321978468622482" +
                           "83972241375657056057490261407972968652414535100474" +
                           "82166370484403199890008895243450658541227588666881" +
                           "16427171479924442928230863465674813919123162824586" +
                           "17866458359124566529476545682848912883142607690042" +
                           "24219022671055626321111109370544217506941658960408" +
                           "07198403850962455444362981230987879927244284909188" +
                           "84580156166097919133875499200524063689912560717606" +
                           "05886116467109405077541002256983155200055935729725" +
                           "71636269561882670428252483600823257530420752963450";

                // Finding the biggest product also means finding the biggest sum.
                // First we put them all into a big list
                List<string> sequences = new List<string>();

                for (int firstDigitIndex = 0; firstDigitIndex + lengthOfProduct <= N.Length; firstDigitIndex++)
                {
                    // With products, order doesn't matter, so we sort the sequences from lowest to highest.
                    string subStr = N.Substring(firstDigitIndex, lengthOfProduct);
                    string sortedStr = String.Concat(subStr.ToCharArray().OrderBy(c => CharToInt(c)));
                    sequences.Add(sortedStr);
                    //Console.WriteLine("Added sequence: " + sequences[^1]);
                }

                // Now that we have this list, lets go through caracter by caracter
                for (int i = 0; i < lengthOfProduct; i++)
                {
                    Console.WriteLine(i);
                    int highest = 0;

                    // Find the sequences with the higest value at this index position and reduce the list to them.
                    foreach (string seq in sequences)
                    {
                        //Console.WriteLine(seq);
                        if (CharToInt(seq[i]) > highest)
                        {
                            highest = CharToInt(seq[i]);
                            sequences = new List<string>() { seq };
                        }
                        else if (CharToInt(seq[i]) == highest)
                        {
                            sequences.Add(seq);
                        }
                    }
                }

                long highestTotal = 0;
                foreach (string seq in sequences)
                {
                    long subTotal = 1;
                    foreach (char c in seq)
                    {
                        subTotal *= CharToInt(c);
                    }
                    if (subTotal > highestTotal)
                    {
                        highestTotal = subTotal;
                    }
                }
                return $"Highest total ({highestTotal}) found at ...";
            }

            public static string Sol_9()
            {
                // Special Pythagorean triplet

                // a+b+c=1000
                // a<b<c

                int[] triplet = new int[3];
                for (int k = 1; true; k++)
                {
                    for (int m = 2; true; m++)
                    {
                        for (int n = 1; n < m; n++)
                        {
                            triplet = GetPythagorianTriplet(m, n, k);
                            if (triplet.Sum() == 1000)
                            {
                                return $"{triplet[0]} * {triplet[1]} * {triplet[2]} = {triplet[0] * triplet[1] * triplet[2]}";
                            }
                        }
                        if (triplet.Sum() > 1000)
                        {
                            break; // Start trying multiples (k>1)
                        }
                    }
                }
                //break;
            }

            public static string Sol_10()
            {
                // Find the sum of all the primes below two million.
                long sum = 0;
                int limit = 2000000;

                // Get all primes below limit
                List<long> P = Prime.GetAllPrimesBelowN(limit);

                // Summate
                foreach (long p in P)
                {
                    sum += p;
                }

                // Return
                return $"Answer: {sum}";
            }

            public static string Sol_11()
            {
                // Largest product in a grid

                int nInProd = 4;

                int[,] Grid = new int[,]{
                { 08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08 },
                { 49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00 },
                { 81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65 },
                { 52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91 },
                { 22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80 },
                { 24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50 },
                { 32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70 },
                { 67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21 },
                { 24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72 },
                { 21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95 },
                { 78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92 }, // Why yes, I did do this all by hand.
                { 16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57 },
                { 86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58 },
                { 19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40 },
                { 04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66 },
                { 88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69 },
                { 04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36 },
                { 20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16 },
                { 20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54 },
                { 01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48 } 
                };

                int gridSize = Grid.GetLength(0); // Assuming its square
                //int[,] prodGrid = new int[gridSize, gridSize];

                int largestProductSoFar = 0;
                int[] largestProdInfo = new int[4];
                bool reCalcNeeded = true;

                // For every row
                for (int y = 0; y < gridSize; y++)
                {
                    // For every col
                    for (int x = 0; x < gridSize; x++)
                    {
                        // Determine the checks that can be done at this coordinate
                        List<Tuple<int, int>> dirSteps = new List<Tuple<int, int>>();

                        // Horizontal (after x=3)
                        if (x >= nInProd - 1)
                        {
                            dirSteps.Add(new Tuple<int, int>(-1, 0));
                        }

                        // Vertical (after y=3)
                        if (y >= nInProd - 1)
                        {
                            dirSteps.Add(new Tuple<int, int>(0, -1));
                        }

                        // Diagonal TopLeft (after x,y = 3)
                        if (y >= nInProd - 1 && x >= nInProd - 1)
                        {
                            dirSteps.Add(new Tuple<int, int>(-1, -1));
                        }

                        // Diagonal BottomLeft (after x = 3 to x = gridSize-4)
                        if (x >= nInProd - 1 && y <= gridSize - nInProd)
                        {
                            dirSteps.Add(new Tuple<int, int>(-1, 1));
                        }

                        // For each direction
                        foreach ((int dx, int dy) in dirSteps)
                        {
                            int prod = 1;

                            // Calculate the product stepwise
                            for (int i = 0; i < nInProd; i++)
                            {
                                prod *= Grid[y + dy*i, x + dx*i];
                            }

                            // Check against largest so far
                            if (prod > largestProductSoFar)
                            {
                                largestProductSoFar = prod;
                                largestProdInfo = new int[] { x, y, dx, dy };
                            }
                        }
                    }
                }
                return $"Largest product ({largestProductSoFar}) found at ({largestProdInfo[0]},{largestProdInfo[1]}), dir: ({largestProdInfo[2]},{largestProdInfo[3]}))";
            }

            public static string Sol_31()
            {
                // Coin sums

                int[] coins = { 1, 2, 5, 10, 20, 50, 100, 200 };
                int target = 200;
                int[] waysToMake = new int[target + 1]; // 0,1,2,3...200

                waysToMake[0] = 1; // We can't make 0p using the coins, but this is done for handiness' sake.
                                   // In the algorithm, this amounts to adding 1 possibility every time t-coin is 0p.

                foreach (int coin in coins) // For every coin
                {
                    for (int t = coin; t <= target; t++)
                    {
                        // Using only coins <= coin, how many ways to make target?
                        waysToMake[t] += waysToMake[t - coin];
                    }
                }
                return $"Answer: {waysToMake[200]}";
            }
        }

        public class Problem
        {
            public int Difficulty, Solved_by;
            public string Title, Discription;
            public Func<string> Solution;

            public Problem(string Title_, string Discription_, int Solved_by_, int Difficulty_, Func<string> Solution_)
            {
                this.Title = Title_;
                this.Discription = Discription_;
                this.Difficulty = Difficulty_;
                this.Solved_by = Solved_by_;
                this.Solution = Solution_;
            }
        }

        public static class Prime
            // This class contains a list of the known primes and related methods.
        {
            public static List<long> Primes;
            public static long largestChecked;

            // Constructor
            static Prime()
            {
                // Add the first prime
                Primes = new List<long>() { 2 };
                largestChecked = 2;
            }

            public static bool IsPrime(long n)
            // This function checks for primality. Since I use all primes below n to determine
            // wether n is prime, another function is refrenced and everything should work.
            {
                // If it has been checked:
                if (largestChecked >= n)
                {
                    return Primes.Contains(Convert.ToInt64(n)); // Return wether it's in the list

                } else 
                {
                    CalcNewPrimes("upToNumber", n);
                    return IsPrime(n);
                }
            }

            public static bool DivisbleByKnownPrimes(long n)
            {
                foreach (long p in Primes)
                {
                    if (n % p == 0) // If it devides evenly
                    {
                        return true;
                    }
                }
                return false;
            }

            public static void CalcNewPrimes(string mode, long n)
            // This funcion calculates new primes.
            // It has a few modes and an input that specify's the amount of new primes
            // to be calculated according to the selected mode.
            {
                switch (mode)
                {
                    case "upToIndex":
                        while (Primes.Count <= n)
                        {
                            // Check if divisible by primes below it
                            largestChecked++;
                            if (!DivisbleByKnownPrimes(largestChecked))
                            {
                                // Add if not divisible
                                Primes.Add(largestChecked);
                            }


                        }
                        return;

                    case "upToNumber":

                        CalcPrimesBelowN_Sieve((int)n);

                        return;

                        //while (largestChecked < n)
                        //{
                        //    CalcNewPrimes("amountOfNew", 1);
                        //}
                        //return;

                    case "amountOfNew":
                        CalcNewPrimes("upToIndex", Primes.Count + n);
                        return;

                    default:
                        Console.WriteLine(String.Format("Primes.calcNewPrimes Error: Unknown mode '{0}'. Valid modes are 'upToIndex' and 'upToNumber'.", mode));
                        return;
                }
            }
            public static long GetPrimeAtIndex(int i)
            // This function returns the i'th prime. (starts at n=0 ==> 2)
            {
                // If the the amount of known primes is not higher than the requested index.
                if (Primes.Count <= i)
                {
                    CalcNewPrimes("upToIndex", i);
                }
                return Primes[i];
            }


            public static List<long> GetAllPrimesBelowN(int n)
            {
                CalcPrimesBelowN_Sieve(n);

                List<long> primesBelowN= new List<long>();
                foreach (long P in Primes)
                {
                    if (P < n)
                    {
                        primesBelowN.Add(P);
                    } else
                    {
                        break;
                    }
                }
                return primesBelowN;
            }

            public static List<long> GetPrimeFactors(long numToFactor)
            {

                // Create list
                List<long> factors = new List<long>();

                while (numToFactor > 1) // We can factor any number > 1 (1 has 0 prime factors)
                {
                    // If prime stop
                    if (Prime.IsPrime(numToFactor))
                    {
                        factors.Add(numToFactor);
                        return factors;
                    } else // Else look for factor
                    {
                        for (int primeI = 0; true; primeI++)
                        {
                            long P = GetPrimeAtIndex(primeI); // get prime
                            if (numToFactor % P == 0) // if divisor
                            {
                                // Divide the number and add the factor to the list of factors.
                                numToFactor /= P;
                                factors.Add(P);
                                break;
                            }
                        }
                    }
                }
                return factors;
            }

            public static void CalcPrimesBelowN_Sieve(int n)
            {
                // Return if nothing has to be calculated
                if (Primes[^1] >= n)
                {
                    return;
                }

                // Create list of candidates (0 ... n-1)
                bool[] candidates = new bool[n]; // Default value is false
                candidates[0] = true; // True means it is seaved out
                candidates[1] = true;

                // Sieve out all multiples of primes that we know
                int primeI = 0;
                while (true)
                {
                    // For every multiple with product below n...
                    for (int mult = 1; Primes[primeI] * mult < n; mult++)
                    {
                        candidates[Primes[primeI] * mult] = true; // Seave it out
                    }

                    int index = Array.IndexOf(candidates, false);
                    
                    if (index == -1)
                    {
                        break;
                    }

                    Primes.Add(index);
                    primeI++;
                }
                largestChecked = n - 1;
            }

        }

        public static string ReverseString(string s)
            // This function reverses a string
        {
            char[] charArray = s.ToCharArray();
            Array.Reverse(charArray);
            return new string(charArray);
        }

        public static int GetLargestPalinDromeBelow(int n_int)
            // This function gives the largest palindrome below n (including n) Example: 99812
        {
            string n_str = n_int.ToString(); // Ex: "99812"
            bool lengthIsEven = n_str.Length % 2 == 0; // Ex: False
            // We determine the different parts of the number. Ex: 99, 8, 12
            string firstHalf_str = n_str.Substring(0, n_str.Length / 2); // This should floor the fraction. Ex: "99" 
            int firstHalf_int = Int32.Parse(firstHalf_str); // Ex: 99
            string secondHalf_str = n_str.Substring(n_str.Length-firstHalf_str.Length); // Ex: "12"
            int secondHalf_int = Int32.Parse(secondHalf_str); // Ex: 12

            //Console.WriteLine(firstHalf_str + " " + secondHalf_str);

            if (firstHalf_str == ReverseString(secondHalf_str))
            // If the second half reversed equals the first half, the number is a palindrome
            {
                //Console.WriteLine("Debug, 1");
                return n_int;
            }
            else if (secondHalf_int >= Int32.Parse(ReverseString(firstHalf_str)))
            // If the second half is >= than the reverse of the first half (Ex: 12>=99 ==> false), than finding the palingdrome is easy.
            // In the case of 32899 for example, the second half (99) can become the reverse of the first half (23).
            {
                //Console.WriteLine("Debug, 2");
                string newPalindrome = firstHalf_str;
                if (!lengthIsEven)
                {
                    newPalindrome += n_str.Length / 2; // Middle caracter is unchanged
                }
                return Int32.Parse(newPalindrome += ReverseString(firstHalf_str)); // Ex: 32899 ==> 32823
            }
            else
            // If the second half was smaller than the reverse of the first half, we take the first half including
            // the middle caracter, subtract 1, and fix the end to be the revers of the start.
            {
                //Console.WriteLine("Debug, 3");
                int firstHalfInclusive = Int32.Parse(n_str.Substring(0, n_str.Length / 2)); // Ex: 998
                int newFirstHalfInclusive = firstHalfInclusive-1; // Ex: 997
                //Console.WriteLine("NewFirstHalfIncl: " + newFirstHalfInclusive);
                string newFirstHalfInclusive_str = newFirstHalfInclusive.ToString(); // Ex: "997"
                int subtract = 0; // Case: even
                if (!lengthIsEven)
                {
                    subtract = 1;
                }
                string newFirstHalf_str = newFirstHalfInclusive_str.Substring(0, newFirstHalfInclusive_str.Length - subtract); // Ex: "99"
                string newSecondHalf_str = ReverseString(newFirstHalf_str);
                string newPalindrome = newFirstHalfInclusive_str + newSecondHalf_str; // Ex: 99799
                return Int32.Parse(newPalindrome);
            }
        }

        public static long LowestCommonMultiple(List<int> ns)
        {
            // Return trivial answer
            if (ns.Count < 2)
            {
                return ns[0];
            }

            Dictionary<int, int> factorHighestCount = new Dictionary<int, int>();
            // For every n
            foreach (int n in ns)
            {
                // Get count of prime factors
                Dictionary<int,int> primeCount = GetCountDictFromList(Prime.GetPrimeFactors(n));
                foreach (int i in primeCount.Keys)
                {

                    if (factorHighestCount.ContainsKey(i)){
                        if (factorHighestCount[i] < primeCount[i])
                        {
                            factorHighestCount[i] = primeCount[i];
                        }
                    } else
                    {
                        factorHighestCount.Add(i, primeCount[i]);
                    }
                }
            }

            // Multiply factors
            int total = 1;
            foreach (int i in factorHighestCount.Keys)
            {
                total *= Convert.ToInt32(Math.Pow(i, factorHighestCount[i]));
            }
            return total;
        }

        public static Dictionary<int, int> GetCountDictFromList(List<long> list)
        {
            Dictionary<int, int> count = new Dictionary<int, int>();
            foreach (int i in list)
            {
                if (count.ContainsKey(i))
                {
                    count[i] += 1;
                } else
                {
                    count.Add(i, 1);
                }
            }
            return count;
        }

        public static int CharToInt(char c)
        {
            return (int)(c - '0');
        }

        public static int[] GetPythagorianTriplet(int m, int n, int k)
            // This function generates pythagorian triplets given natural numbers k, m and n
            // While m>n
        {
            int a = k * (m * m - n * n);
            int b = k * (2 * m * n);
            int c = k * (m * m + n * n);
            return new int[] { a,b,c };
        }
    }
}