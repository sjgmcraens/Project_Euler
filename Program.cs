using System;
using System.Collections;
using System.Collections.Generic;
using System.Data.Common;
using System.Dynamic;
using System.Linq;
using System.Reflection;
using System.Runtime;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using System.Xml.Schema;

namespace Project_Euler
{
    class Program
    {

        static void Main()
        {
            // Variabes we might need.
            string sectionBar = "\n========================================================================================================================\n";
            //bool firstMenuLoop = true;

            // Main loop ==> Like a menu, you can come back to it or exit out.
            while (true)
            {

                // Show the user a list of the problems
                Console.WriteLine(sectionBar);
                Console.WriteLine("List of problems: ("+Problems.P.Count+" total)");
                foreach (KeyValuePair<int, Problem> entry in Problems.P.OrderBy(key => key.Key))
                {
                    Console.WriteLine(String.Format("[{0}]: {1}", entry.Key, entry.Value.Title));
                }



                // Ask the user to input the ID of the desired problem; the program can be exited at this point.
                Console.WriteLine(sectionBar);
                Console.WriteLine("Please input the ID of a problem to print it's details.\n" +
                    "To exit the program, input 'exit'.");
                string Input = Console.ReadLine();
                if (Input == "exit") { return; }
                int ID = Convert.ToInt32(Input);

                // Some control for input
                while (!Problems.P.ContainsKey(ID))
                {
                    Console.WriteLine("Please input an existing ID.");
                    Input = Console.ReadLine();
                    if (Input == "exit") { return; }
                    ID = Convert.ToInt32(Input);
                }

                // Print the details of the selected problem
                Console.WriteLine(sectionBar);
                Problem p = Problems.P[ID];
                Console.WriteLine(p.Title + ":\n" + p.Discription + "\n\nSolved by: " +
                    p.Solved_by + "\nDifficulty: " + p.Difficulty + "%\n\nSolution: " + p.Solution());

                // Ask the user what to do next
                Console.WriteLine(sectionBar);
                Console.WriteLine("Input 'exit' to exit the program; any other input will return you to the list of problems.");
                Input = Console.ReadLine();
                // If the input isn't '1', close the program
                if (Input == "exit")
                {
                    return;
                }

                //firstMenuLoop = false;
            }
        }

        static class Problems
        // This class contains the information pertaining to the all the problems.
        {
            // Dictinairy of problems
            public static readonly Dictionary<int, Problem> P;

            static Problems() // This is the constructor: below, we fill 'P' and add methods for returning the solution to the problems.
            {

                P = new Dictionary<int, Problem>();

                P.Add(1, new Problem("Multiples of 3 and 5",
                    "If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.\n" +
                    "Find the sum of all the multiples of 3 or 5 below 1000.",
                    964994, 5, Sol_1));

                P.Add(7, new Problem("10001st prime",
                    "By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.\n" +
                    "What is the 10 001st prime number?",
                    421486, 5, Sol_7));

                P.Add(31, new Problem("Coin sums",
                    "In the United Kingdom the currency is made up of pound (£) and pence (p). There are eight coins in general circulation:\n" +
                    "1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), and £2 (200p).\n" +
                    "It is possible to make £2 in the following way:\n" +
                    "1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p\n" +
                    "How many different ways can £2 be made using any number of coins?",
                    84093, 5, Sol_31));

                P.Add(2, new Problem("Even Fibonacci numbers",
                    "Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:\n" +
                    "1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n" +
                    "By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.",
                    768279, 5, Sol_2));

                P.Add(3, new Problem("Largest prime factor",
                    "The prime factors of 13195 are 5, 7, 13 and 29.\n" +
                    "What is the largest prime factor of the number 600851475143 ?",
                    550872, 5, Sol_3));

                P.Add(4, new Problem("Largest palindrome product",
                    "A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.\n" +
                    "Find the largest palindrome made from the product of two 3-digit numbers.",
                    486673, 5, Sol_4));
                
                P.Add(5, new Problem("Smallest multiple",
                    "2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.\n" +
                    "What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?",
                    486673, 5, Sol_5));

                P.Add(6, new Problem("Sum square difference",
                    "The sum of the squares of the first ten natural numbers is,\n" +
                    "1+4+9+...+100 = 385\n" +
                    "The square of the sum of the first ten natural numbers is,\n" +
                    "(1+2+3+...+10)^2 = 3025\n" +
                    "Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is,\n" +
                    "3025-385 = 2640\n" +
                    "Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.",
                    493325, 5, Sol_6));

                P.Add(8, new Problem("Largest product in a series",
                    "The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.,\n" +
                    "73167176531330624919225119674426574742355349194934\n" +
                    "96983520312774506326239578318016984801869478851843\n" +
                    "85861560789112949495459501737958331952853208805511\n" +
                    "12540698747158523863050715693290963295227443043557\n" +
                    "66896648950445244523161731856403098711121722383113\n" +
                    "62229893423380308135336276614282806444486645238749\n" +
                    "30358907296290491560440772390713810515859307960866\n" +
                    "70172427121883998797908792274921901699720888093776\n" +
                    "65727333001053367881220235421809751254540594752243\n" +
                    "52584907711670556013604839586446706324415722155397\n" +
                    "53697817977846174064955149290862569321978468622482\n" +
                    "83972241375657056057490261407972968652414535100474\n" +
                    "82166370484403199890008895243450658541227588666881\n" +
                    "16427171479924442928230863465674813919123162824586\n" +
                    "17866458359124566529476545682848912883142607690042\n" +
                    "24219022671055626321111109370544217506941658960408\n" +
                    "07198403850962455444362981230987879927244284909188\n" +
                    "84580156166097919133875499200524063689912560717606\n" +
                    "05886116467109405077541002256983155200055935729725\n" +
                    "71636269561882670428252483600823257530420752963450\n" +
                    "Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?",
                    352346, 5, Sol_8));

                P.Add(9, new Problem("Special Pythagorean triplet",
                    "A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,\n" +
                    "a2 + b2 = c2\n" +
                    "For example, 32 + 42 = 9 + 16 = 25 = 52.\n" +
                    "There exists exactly one Pythagorean triplet for which a + b + c = 1000.\n" +
                    "Find the product abc.\n",
                    357757, 5, Sol_9));

                P.Add(10, new Problem("Summation of primes",
                    "The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.\n" +
                    "Find the sum of all the primes below two million.\n",
                    327678, 5, Sol_10));
            }

            public static long Sol_1()
            {
                // Multiples of 3 and 5

                // For every natural number under 1000
                int stopAt = 1000;
                int total = 0;
                for (int i = 0; i < stopAt; i++)
                {
                    // Add it to the total if it is divisible by 3 or 5
                    if (i % 3 == 0 || i % 5 == 0)
                    {
                        total += i;
                    }
                }
                return total;
            }

            public static long Sol_2() // Even Fibbonachi numbers
            {
                List<int> Fib = new List<int>() { 1, 2 };
                int target = 4000000;
                long total = 2;
                while (Fib[Fib.Count - 1] < target) // While < 4000000
                {
                    int nextFib = Fib[Fib.Count - 1] + Fib[Fib.Count - 2];
                    Fib.Add(nextFib);
                    if (nextFib % 2 == 0) // If even
                    {
                        total += nextFib;
                    }
                }
                return total;
            }

            public static long Sol_3()
            {
                //Largest prime factor
                long numToFactor = 600851475143;
                List<long> factors = Prime.GetPrimeFactors(numToFactor);
                return factors.Max();
            }

            public static long Sol_4()
            {
                //Largest palindrome product

                // I think it's best to check palindrome from largest to smallest.
                // Since it must be a multiple of two three-digit numbers, 998001 is going to be the starting point.
                // Instead of brute-forcing all multiplications (999*999, 998*999 ...), Lets go down from 998001 
                // and keep checking palindromes untill we find one that can be made with two three-digit numbers. 

                // Settings
                int Multdigits = 3;
                int Multamount = 2; // Doesn't work for inputs > 2 unfortunately.

                // Some preparatory calculations.
                int maxMult = Int32.Parse(String.Concat(Enumerable.Repeat("9", Multdigits))); // 999
                int maxTotal = Convert.ToInt32(Math.Pow(maxMult, Multamount)); // 999*999 = 998001

                int minMult = Convert.ToInt32(Math.Pow(10, Multdigits - 1)); // 100
                int minTotal = Convert.ToInt32(Math.Pow(minMult, Multamount)); // 100*100 = 100000

                string maxTotal_str = Math.Pow(maxMult, Multamount).ToString(); // 998001

                // Determine first palindrome
                int palindrome = GetLargestPalinDromeBelow(maxTotal);

                while (palindrome >= minTotal)
                {
                    //Console.WriteLine(palindrome);

                    // Now that we have a palindrome, lets check whether it can be made using two three-digit numbers
                    for (int i = maxMult; i >= minMult; i--) // 999, 998, ... , 100
                    {
                        if (palindrome % i == 0) // If wholly divisible (to completely generalize: make this recursive)
                        {
                            if ((palindrome / i).ToString().Length == Multdigits) // If the division creates a 3-digit number.
                            {
                                //Console.WriteLine(String.Format("Palindrome {0} can be made using {1} x {2}",palindrome,i,palindrome / i));
                                return palindrome; // Return the succesfull palindrome.
                            }
                        }
                    }
                    palindrome = GetLargestPalinDromeBelow(palindrome - 1);
                }
                // No solution was found.
                return -1;
            }

            public static long Sol_5()
            {
                // Smallest multiple

                List<int> ns = new List<int>();
                for (int i = 1; i <= 20; i++)
                {
                    ns.Add(i);
                }
                return LowestCommonMultiple(ns);
            }

            public static long Sol_6()
            {
                // Sum square difference

                int upTo = 100;
                double sumOfQuares = 0;
                int sum = 0;
                for (int i = 1; i <= upTo; i++)
                {
                    sumOfQuares += Math.Pow(i, 2);
                    sum += i;
                }
                double squareOfSum = Math.Pow(sum, 2);
                return Convert.ToInt64(Math.Abs(squareOfSum - sumOfQuares));
            }


            public static long Sol_7() // 10001st prime
            {
                return Prime.GetPrimeAtIndex(10000); // See also the static class 'Prime'
            }

            public static long Sol_8()
            {
                int lengthOfProduct = 13;

                string N = "73167176531330624919225119674426574742355349194934" +
                           "96983520312774506326239578318016984801869478851843" +
                           "85861560789112949495459501737958331952853208805511" +
                           "12540698747158523863050715693290963295227443043557" +
                           "66896648950445244523161731856403098711121722383113" +
                           "62229893423380308135336276614282806444486645238749" +
                           "30358907296290491560440772390713810515859307960866" +
                           "70172427121883998797908792274921901699720888093776" +
                           "65727333001053367881220235421809751254540594752243" +
                           "52584907711670556013604839586446706324415722155397" +
                           "53697817977846174064955149290862569321978468622482" +
                           "83972241375657056057490261407972968652414535100474" +
                           "82166370484403199890008895243450658541227588666881" +
                           "16427171479924442928230863465674813919123162824586" +
                           "17866458359124566529476545682848912883142607690042" +
                           "24219022671055626321111109370544217506941658960408" +
                           "07198403850962455444362981230987879927244284909188" +
                           "84580156166097919133875499200524063689912560717606" +
                           "05886116467109405077541002256983155200055935729725" +
                           "71636269561882670428252483600823257530420752963450";

                // Finding the biggest product also means finding the biggest sum.
                // First we put them all into a big list
                List<string> sequences = new List<string>();

                for (int firstDigitIndex = 0; firstDigitIndex + lengthOfProduct <= N.Length; firstDigitIndex++)
                {
                    // With products, order doesn't matter, so we sort the sequences from lowest to highest.
                    string subStr = N.Substring(firstDigitIndex, lengthOfProduct);
                    string sortedStr = String.Concat(subStr.ToCharArray().OrderBy(c => CharToInt(c)));
                    sequences.Add(sortedStr);
                    //Console.WriteLine("Added sequence: " + sequences[^1]);
                }

                // Now that we have this list, lets go through caracter by caracter
                for (int i = 0; i < lengthOfProduct; i++)
                {
                    Console.WriteLine(i);
                    int highest = 0;

                    // Find the sequences with the higest value at this index position and reduce the list to them.
                    foreach (string seq in sequences)
                    {
                        //Console.WriteLine(seq);
                        if (CharToInt(seq[i]) > highest)
                        {
                            highest = CharToInt(seq[i]);
                            sequences = new List<string>() { seq };
                        }
                        else if (CharToInt(seq[i]) == highest)
                        {
                            sequences.Add(seq);
                        }
                    }
                }

                long highestTotal = 0;
                foreach (string seq in sequences)
                {
                    long subTotal = 1;
                    foreach (char c in seq)
                    {
                        subTotal *= CharToInt(c);
                    }
                    if (subTotal > highestTotal)
                    {
                        highestTotal = subTotal;
                    }
                }
                return highestTotal;
            }

            public static long Sol_9()
            {
                // Special Pythagorean triplet

                // a+b+c=1000
                // a<b<c

                int[] triplet = new int[3];
                for (int k = 1; true; k++)
                {
                    for (int m = 2; true; m++)
                    {
                        for (int n = 1; n < m; n++)
                        {
                            triplet = GetPythagorianTriplet(m, n, k);
                            if (triplet.Sum() == 1000)
                            {
                                return triplet[0] * triplet[1] * triplet[2];
                            }
                        }
                        if (triplet.Sum() > 1000)
                        {
                            break; // Start trying multiples (k>1)
                        }
                    }
                }
                //break;
            }

            public static long Sol_10()
            {
                // Find the sum of all the primes below two million.
                long Sum = 0;
                int limit = 2000000;

                // Get all primes below limit
                List<long> P = Prime.GetAllPrimesBelowN(limit);

                // Summate
                foreach (long p in P)
                {
                    Sum += p;
                }

                // Return
                return Sum;
            }

            public static long Sol_31()
            {
                // Coin sums

                int[] coins = { 1, 2, 5, 10, 20, 50, 100, 200 };
                int target = 200;
                int[] waysToMake = new int[target + 1]; // 0,1,2,3...200

                waysToMake[0] = 1; // We can't make 0p using the coins, but this is done for handiness' sake.
                                   // In the algorithm, this amounts to adding 1 possibility every time t-coin is 0p.

                foreach (int coin in coins) // For every coin
                {
                    for (int t = coin; t <= target; t++)
                    {
                        // Using only coins <= coin, how many ways to make target?
                        waysToMake[t] += waysToMake[t - coin];
                    }
                }
                return waysToMake[200];
            }
        }

        public class Problem
        {
            public int Difficulty, Solved_by;
            public string Title, Discription;
            public Func<long> Solution;

            public Problem(string Title_, string Discription_, int Solved_by_, int Difficulty_, Func<long> Solution_)
            {
                this.Title = Title_;
                this.Discription = Discription_;
                this.Difficulty = Difficulty_;
                this.Solved_by = Solved_by_;
                this.Solution = Solution_;
            }
        }

        public static class Prime
            // This class contains a list of the known primes and related methods.
        {
            public static List<long> Primes;
            public static long largestChecked;

            // Constructor
            static Prime()
            {
                // Add the first prime
                Primes = new List<long>() { 2 };
                largestChecked = 2;
            }

            public static bool IsPrime(long n)
            // This function checks for primality. Since I use all primes below n to determine
            // wether n is prime, another function is refrenced and everything should work.
            {
                // If it has been checked:
                if (largestChecked >= n)
                {
                    return Primes.Contains(Convert.ToInt64(n)); // Return wether it's in the list

                } else 
                {
                    CalcNewPrimes("upToNumber", n);
                    return IsPrime(n);
                }
            }

            public static bool DivisbleByKnownPrimes(long n)
            {
                foreach (long p in Primes)
                {
                    if (n % p == 0) // If it devides evenly
                    {
                        return true;
                    }
                }
                return false;
            }

            public static void CalcNewPrimes(string mode, long n)
            // This funcion calculates new primes.
            // It has a few modes and an input that specify's the amount of new primes
            // to be calculated according to the selected mode.
            {
                switch (mode)
                {
                    case "upToIndex":
                        while (Primes.Count <= n)
                        {
                            // Check if divisible by primes below it
                            largestChecked++;
                            if (!DivisbleByKnownPrimes(largestChecked))
                            {
                                // Add if not divisible
                                Primes.Add(largestChecked);
                            }


                        }
                        return;

                    case "upToNumber":

                        CalcPrimesBelowN_Sieve((int)n);

                        return;

                        //while (largestChecked < n)
                        //{
                        //    CalcNewPrimes("amountOfNew", 1);
                        //}
                        //return;

                    case "amountOfNew":
                        CalcNewPrimes("upToIndex", Primes.Count + n);
                        return;

                    default:
                        Console.WriteLine(String.Format("Primes.calcNewPrimes Error: Unknown mode '{0}'. Valid modes are 'upToIndex' and 'upToNumber'.", mode));
                        return;
                }
            }
            public static long GetPrimeAtIndex(int i)
            // This function returns the i'th prime. (starts at n=0 ==> 2)
            {
                // If the the amount of known primes is not higher than the requested index.
                if (Primes.Count <= i)
                {
                    CalcNewPrimes("upToIndex", i);
                }
                return Primes[i];
            }


            public static List<long> GetAllPrimesBelowN(int n)
            {
                CalcPrimesBelowN_Sieve(n);

                List<long> primesBelowN= new List<long>();
                foreach (long P in Primes)
                {
                    if (P < n)
                    {
                        primesBelowN.Add(P);
                    } else
                    {
                        break;
                    }
                }
                return primesBelowN;
            }

            public static List<long> GetPrimeFactors(long numToFactor)
            {

                // Create list
                List<long> factors = new List<long>();

                while (numToFactor > 1) // We can factor any number > 1 (1 has 0 prime factors)
                {
                    // If prime stop
                    if (Prime.IsPrime(numToFactor))
                    {
                        factors.Add(numToFactor);
                        return factors;
                    } else // Else look for factor
                    {
                        for (int primeI = 0; true; primeI++)
                        {
                            long P = GetPrimeAtIndex(primeI); // get prime
                            if (numToFactor % P == 0) // if divisor
                            {
                                // Divide the number and add the factor to the list of factors.
                                numToFactor /= P;
                                factors.Add(P);
                                break;
                            }
                        }
                    }
                }
                return factors;
            }

            public static void CalcPrimesBelowN_Sieve(int n)
            {
                // Return if nothing has to be calculated
                if (Primes[^1] >= n)
                {
                    return;
                }

                // Create list of candidates (0 ... n-1)
                bool[] candidates = new bool[n]; // Default value is false
                candidates[0] = true; // True means it is seaved out
                candidates[1] = true;

                // Sieve out all multiples of primes that we know
                int primeI = 0;
                while (true)
                {
                    // For every multiple with product below n...
                    for (int mult = 1; Primes[primeI] * mult < n; mult++)
                    {
                        candidates[Primes[primeI] * mult] = true; // Seave it out
                    }

                    int index = Array.IndexOf(candidates, false);
                    
                    if (index == -1)
                    {
                        break;
                    }

                    Primes.Add(index);
                    primeI++;
                }
                largestChecked = n - 1;
            }

        }

        public static string ReverseString(string s)
            // This function reverses a string
        {
            char[] charArray = s.ToCharArray();
            Array.Reverse(charArray);
            return new string(charArray);
        }

        public static int GetLargestPalinDromeBelow(int n_int)
            // This function gives the largest palindrome below n (including n) Example: 99812
        {
            string n_str = n_int.ToString(); // Ex: "99812"
            bool lengthIsEven = n_str.Length % 2 == 0; // Ex: False
            // We determine the different parts of the number. Ex: 99, 8, 12
            string firstHalf_str = n_str.Substring(0, n_str.Length / 2); // This should floor the fraction. Ex: "99" 
            int firstHalf_int = Int32.Parse(firstHalf_str); // Ex: 99
            string secondHalf_str = n_str.Substring(n_str.Length-firstHalf_str.Length); // Ex: "12"
            int secondHalf_int = Int32.Parse(secondHalf_str); // Ex: 12

            //Console.WriteLine(firstHalf_str + " " + secondHalf_str);

            if (firstHalf_str == ReverseString(secondHalf_str))
            // If the second half reversed equals the first half, the number is a palindrome
            {
                //Console.WriteLine("Debug, 1");
                return n_int;
            }
            else if (secondHalf_int >= Int32.Parse(ReverseString(firstHalf_str)))
            // If the second half is >= than the reverse of the first half (Ex: 12>=99 ==> false), than finding the palingdrome is easy.
            // In the case of 32899 for example, the second half (99) can become the reverse of the first half (23).
            {
                //Console.WriteLine("Debug, 2");
                string newPalindrome = firstHalf_str;
                if (!lengthIsEven)
                {
                    newPalindrome += n_str.Length / 2; // Middle caracter is unchanged
                }
                return Int32.Parse(newPalindrome += ReverseString(firstHalf_str)); // Ex: 32899 ==> 32823
            }
            else
            // If the second half was smaller than the reverse of the first half, we take the first half including
            // the middle caracter, subtract 1, and fix the end to be the revers of the start.
            {
                //Console.WriteLine("Debug, 3");
                int firstHalfInclusive = Int32.Parse(n_str.Substring(0, n_str.Length / 2)); // Ex: 998
                int newFirstHalfInclusive = firstHalfInclusive-1; // Ex: 997
                //Console.WriteLine("NewFirstHalfIncl: " + newFirstHalfInclusive);
                string newFirstHalfInclusive_str = newFirstHalfInclusive.ToString(); // Ex: "997"
                int subtract = 0; // Case: even
                if (!lengthIsEven)
                {
                    subtract = 1;
                }
                string newFirstHalf_str = newFirstHalfInclusive_str.Substring(0, newFirstHalfInclusive_str.Length - subtract); // Ex: "99"
                string newSecondHalf_str = ReverseString(newFirstHalf_str);
                string newPalindrome = newFirstHalfInclusive_str + newSecondHalf_str; // Ex: 99799
                return Int32.Parse(newPalindrome);
            }
        }

        public static long LowestCommonMultiple(List<int> ns)
        {
            // Return trivial answer
            if (ns.Count < 2)
            {
                return ns[0];
            }

            Dictionary<int, int> factorHighestCount = new Dictionary<int, int>();
            // For every n
            foreach (int n in ns)
            {
                // Get count of prime factors
                Dictionary<int,int> primeCount = GetCountDictFromList(Prime.GetPrimeFactors(n));
                foreach (int i in primeCount.Keys)
                {

                    if (factorHighestCount.ContainsKey(i)){
                        if (factorHighestCount[i] < primeCount[i])
                        {
                            factorHighestCount[i] = primeCount[i];
                        }
                    } else
                    {
                        factorHighestCount.Add(i, primeCount[i]);
                    }
                }
            }

            // Multiply factors
            int total = 1;
            foreach (int i in factorHighestCount.Keys)
            {
                total *= Convert.ToInt32(Math.Pow(i, factorHighestCount[i]));
            }
            return total;
        }

        public static Dictionary<int, int> GetCountDictFromList(List<long> list)
        {
            Dictionary<int, int> count = new Dictionary<int, int>();
            foreach (int i in list)
            {
                if (count.ContainsKey(i))
                {
                    count[i] += 1;
                } else
                {
                    count.Add(i, 1);
                }
            }
            return count;
        }

        public static int CharToInt(char c)
        {
            return (int)(c - '0');
        }

        public static int[] GetPythagorianTriplet(int m, int n, int k)
            // This function generates pythagorian triplets given natural numbers k, m and n
            // While m>n
        {
            int a = k * (m * m - n * n);
            int b = k * (2 * m * n);
            int c = k * (m * m + n * n);
            return new int[] { a,b,c };
        }
    }
}